🔗 JPA 연관관계 매핑 정리
1. 개념적 배경
(1) 서로 다른 두 세계

데이터베이스 세계

테이블 간 관계를 외래키(Foreign Key) 로 정의한다.

한쪽 테이블에만 외래키가 존재해도 양방향 조인이 가능하다.

객체 지향 세계

객체 간 관계는 참조(필드) 로 표현한다.

참조 필드가 있어야만 다른 객체로 탐색할 수 있다.

즉, 참조가 없는 쪽에서는 관계를 전혀 인지할 수 없다.

➡️ 따라서 JPA에서는 이 두 세계의 패러다임 차이를 해결하기 위해 연관관계 매핑이 필요하다.

2. 객체 그래프 탐색

엔터티 객체가 가진 참조 필드를 따라가며 연관된 엔터티에 접근하는 것을 의미한다.

Post post = em.find(Post.class, 1L);
System.out.println(post.getUser().getName());


post.getUser() → 참조 필드를 통해 작성자 객체 탐색

SQL 조인을 작성하지 않아도 객체 그래프 탐색으로 자연스럽게 관계를 추적할 수 있다.

3. 연관관계의 주인 (Owning Side)

실제 외래키를 가진 엔터티가 연관관계의 주인이다.

주인만이 외래키 값을 등록·수정할 수 있다.

반대편은 조회용(read-only) 으로만 사용된다.

이는 데이터 값 자체의 변경이 아니라 관계(연결)의 변경을 의미한다.

4. 연관관계 종류
(1) 단방향 연관관계 — “나만 너를 안다”
@Entity
public class Post {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @ManyToOne
    @JoinColumn(name = "user_id")  // FK: post.user_id = user.id
    private User user;
}

@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;
}


Post → User 탐색 가능

User → Post 탐색 불가

장점

불필요한 의존 관계를 줄인다.

구조가 단순하고 명확하다.

필요 시 mappedBy를 추가해 양방향으로 확장 가능하다.

(2) 양방향 연관관계 — “나도 너를 알아”
@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    private String name;

    @OneToMany(mappedBy = "user")
    private List<Post> posts = new ArrayList<>();
}

@Entity
public class Post {
    @Id @GeneratedValue
    private Long id;
    private String title;

    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}


User는 posts 컬렉션으로 자신이 쓴 게시글을 알고,

Post는 user 필드로 작성자를 안다.

DB에는 외래키가 하나만 존재하지만, 자바 객체에서는 양쪽 탐색 가능.

예시

User user = em.find(User.class, 1L);
for (Post post : user.getPosts()) {
    System.out.println(post.getTitle());
}

SELECT p.* FROM post p WHERE p.user_id = 1;


➡️ 객체 그래프 탐색만으로 SQL 조인을 자동으로 수행한다.

5. 관계 상태 변경 시 주의점

게시글의 작성자를 A → B로 변경할 때:

DB에서는 post.user_id 값만 바꾸면 끝이지만,

자바 객체에서는 양쪽 참조 모두 수정해야 일관성이 유지된다.

post.setUser(newUser);
newUser.getPosts().add(post);


JPA의 영속성 컨텍스트는 객체 상태를 기준으로 동기화하기 때문에
양쪽 참조를 맞추지 않으면 예상치 못한 불일치가 발생할 수 있다.

6. ManyToOne 관계

N : 1 관계

N쪽 엔터티가 외래키를 가진다.

즉, N쪽이 연관관계의 주인이다.

구분	특징
단방향	N쪽만 1쪽을 참조
양방향	N쪽은 1쪽을 참조, 1쪽은 mappedBy로 N쪽 컬렉션을 조회용 보유
탐색 방향	단방향	양방향
게시글 → 작성자	✅	✅
작성자 → 게시글	❌	✅
7. N + 1 문제

하나의 엔터티를 조회할 때, 연관된 엔터티를 N번 반복 조회하는 문제

(예시)

User (1) : Post (N) 관계에서 모든 게시글을 조회하며 작성자 이름도 출력할 때:

-- 1. 게시글 전체 조회
SELECT p.* FROM post p;

-- 2. 게시글마다 작성자 조회 (N번 발생)
SELECT u.* FROM user u WHERE u.id = ?;
SELECT u.* FROM user u WHERE u.id = ?;
...


➡️ 처음 쿼리 1회 + 연관 엔터티 N회 = N + 1 문제

8. Fetch 전략으로 로딩 시점 제어
전략	설명	장단점
Lazy Loading	연관 객체를 프록시로 두고, 실제 접근 시 쿼리 실행	필요할 때만 조회하지만, 여전히 N+1 발생
Eager Loading	처음부터 조인으로 함께 조회	불필요한 데이터까지 조회 가능 (과조회 위험)
9. N + 1 문제 해결 방법
(1) Fetch Join (JPQL)
SELECT p FROM Post p JOIN FETCH p.user;


연관된 엔터티를 즉시 조인으로 함께 가져온다.

다만, 중복 데이터가 발생할 수 있음.

(2) Entity Graph
@EntityGraph(attributePaths = {"user"})
@Query("SELECT p FROM Post p")
List<Post> findAllWithUser();


JPQL을 수정하지 않고 어노테이션으로 즉시 로딩 설정.

내부적으로 JOIN FETCH와 동일한 쿼리를 생성한다.