작성일 | 251028 

### 맥락 정리

- ORM은 자바 객체를 테이블에 연결지어주는 기술
- JPA는 ORM의 표준 명세
- Hibernate는 JPA 구현 라이브러리
- 실행 구조
    
    DBMS(데이터베이스) → JDBC (자바 ↔ 데이터베이스 연결) → Hibernate(JPA 구체 구현체) → JPA (JPA 표준 명세)→ Spring Data JPA (JPA 추상화 프레임워크)
    
- 자바의 객체 지향 프로그래밍에서 등장하는 많은 객체들을 우리는 어떻게 테이블의 행 데이터로 구분할 수 있을까? 데이터베이스에서 사용하는 주요 식별자를 객체에도 적용해보자! ⇒ @Id 어노테이션
- 객체를 식별할 수 있어야 엔터티의 생명주기를 관리할 수 있다.
    - 이미 존재하는 객체인지 아니면 새로 저장해야하는 데이터인지 판별하는 과정

# 기본 키 (Primary Key)

> 데이터를 구분하기 위해 사용하는 키 데이터마다 유일하게 식별할 수 있다.
> 

기본키는 우리가 언제 쓸까? 데이터베이스의 데이터를 구분하기 위해 사용한다. 기본키는 데이터마다 유일한 값을 갖게 된다.  자바 객체의 차원에서 기본키를 사용하기 위해 필요한 어노테이션이 바로 `@Id` 이다. 

해당 필드를 기준으로 영속성 컨텍스트에서 객체를 관리한다.→ 직관적으로 보면 새로 생성한 데이터인지 아니면 이미 존재하는 데이터인지 구분하는 용도라고 볼 수 있다. 

기본 키가 있어야 동일한 엔터티를 여러 번 조회했을 때 동일한 인스턴스로 인식할 수 있다. → 변경 감지, 1차 캐시 관리, 병합 등의 기능을 수행할 수 있다. 

⇒ 하나의 트랜잭션 안에서 기본키를 통해 엔터티를 식별하고 엔터티에 적용되는 트랜잭션 연산의 결과를 반영할 수 있다. 

## 기본 키 할당 방식

1. **직접 할당** : 개발자가 기본 키 값을 직접 세팅하여 저장하는 방식 
    
    ```java
    @Id
    private Long id; // 저장 전 직접 값 세팅 
    ```
    
2. **자동 생성** : JPA가 기본키를 자동으로 생성하도록 위임하는 방식 
    
    `@GeneratedValue` 어노테이션 사용해서 JPA가 자동으로 기본키를 생성하는 방식 
    

## JPA의 1차 캐시가 동작하는 방식과 @Id의 역할

영속성 컨텍스트라는 메모리 공간에서 엔터티 객체가 저장되고 관리된다. 

엔터티 조회요청이 들어가면 영속성 컨텍스트의 내부 맵에서 해당 엔터티의 아이디 값과 엔터티 클래스명으로 엔터티 객체를 조회한다. 

아이디 어노테이션가 붙어있는 객체 필드의 값을 활용해 엔터티 객체를 조회할때 사용한다. 

이때 @Id가 없으면 어떤 엔터티인지 식별할 수 없다. 

# @GeneratedValue

> PK 값을 수동으로 관리할수도 있지만 실무에서는 대부분 DB가 자동으로 생성하도록 설정
> 

## AUTO

- JPA가 DBMS 특성에 맞춰서 자동으로 키를 생성하고 매핑해주는 방법
- 성능최적화가 필요하거나 특정 전략을 강제로 사용해야하는 경우 → AUTO 대신 원하는 전략을 명확히 지정하는

## IDENTITY

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String email;
}
```

- 데이터베이스의 자동 증가 컬럼
- MySQL의 `Auto_Increment`
- 엔터티를 persist하는 순간 즉시 `Insert` 쿼리가 실행되고 데이터베이스가 생성한 키 값을 조회
- 쓰기 지연 / 배치 인서트에는 제약이 있다.

📍**IDENTITY 전략을 사용할 때 persist() 호출 시점에 즉시 INSERT가 발생하는 이유는 무엇일까.**

1. Identity 전략의 경우 엔터티의 아이디 값을 데이터베이스에서만 생성할 수 있기 때문에 persist 호출 즉시 인서트가 발생한다. 
2. Identity 전략을 사용할 때에는 기본키 값이 데이터베이스 디스크에 존재한다. 
3. 엔터티 객체를 영속성 컨텍스트에 등록하면서 아이디를 데이터베이스에서 불러온다. 
4. 그래서 아이덴티티 전략을 사용할 때는 persist() 호출 순간 즉시 insert되어야한다. ⇒ 고로 배치 인서트가 안된다. 

## SEQUENCE

```java
@Entity
@SequenceGenerator(
    name = "post_seq",
    sequenceName = "post_seq",
    allocationSize = 50
)
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "post_seq")
    private Long id;
    private String title;
}
```

- DB에 존재하는 시퀀스 오브젝트를 이용해 기본 키 값을 생성하는 방식 → `NEXTVAL`이라는 명령어를 호출할때마다 중복되지 않는 유일한 숫자를 순차적으로 반환
- (배치 처리 가능) 한번에 `allocatedSize` 개수 만큼의 인덱스를 미리 메모리에 받아올 수 있다. → 불필요한 조회가 없어 성능상의 이점이 존재한다.
- 쓰기 지연이 된다. → 여러 번 데이터베이스에 접근하지 않아도 되기 때문에 불필요한 i/o를 막을 수 있다.
- MySQL의 경우 시퀀스 객체를 가지고 잊지 않는다. → Hibernate가 table 전략처럼 별도의 시퀀스 테이블을 만들어 사용한다.

---

📍 **DB에 존재하는 시퀀스 오브젝트**

- 자동으로 순차적으로 증가하는 순번을 반환하는 객체
- 중복값을 방지하기 위해 사용

📍 `allocationSize` 

- 디스크로부터 불러올 시퀀스의 범위를 지정해주는 값
- 여러 개의 키를 한 번에 가져와 메모리에 저장해두고 추가 통신 없이 순차적으로 소모 → 성능 향상

📍 **SEQUENCE 전략의 allocationSize 옵션이 무엇이며, 왜 성능 최적화에 중요할까?**

- 시퀀스 전략은 데이터베이스로부터 한번에 키 값을 받아와 메모리에 저장하고 해당 키 값을 기준으로 데이터베이스의 인덱스 값을 정해준다.
- 이때 가져올 인덱스의 범위를 정해주는 것이 `allocationSize` 옵션입니다.
- 배치 단위로 변경이 적용되고 인서트를 적용할 수 있어 성능 최적화에 도움이 됩니다.
- 데이터를 insert할 때 묶음 단위로 진행할 수 있다.
    - 만약 `allocationSize`를 사용하지 않는 경우 매 시퀀스에 대해서 입력해줘야 함

## TABLE

- 키 전용 테이블을 만들어서 시퀀스처럼 동작하는 방식
- 데이터베이스에 id_generator 라는 이름의 테이블을 하나 생성 → 각 엔터티별로 다음에 사용할 id 값을 기록해두는 방식
- 성능이 좋지 않아서 자주 사용되지 않음

# 자연 키 / 대리 키

테이블의 키(pk)를 설정하는 과정에서 적용되는 원칙 

**자연키** : 비즈니스적으로 의미가 있는 값 → 회원의 이메일이나 학생의 학번 같은 값 

유일해야하는 값은 `unique` 제약 조건을 걸고 관리 

**대리키** : 비즈니스적으로 의미가 없는 값 → 자동으로 생성해주는 연속된 숫자 값(시퀀스)

기본키는 불변성을 갖는다. 즉 절대 변하면 안된다. ⇒ 대부분 대리키를 사용한다.

# UUID

***universally unique identifier***

- 128비트의 고유 식별자로 자바, DB 등 애플리케이션에서 쉽게 발급 가능
- 문자열 형식이며 랜덤하게 생성됨 → 재정렬의 필요성이 있어 조회 성능이 떨어진다.
- 중앙 시스템에 등록하고 발급하는 과정 없이 빠르고 간단하게 발급 가능 → 분산 환경, 외부 연동이 쉽다.
- 구조
    
    ![image.png](https://static.tosspayments.com/docs/glossary/uuid-img1.png)
    

https://docs.tosspayments.com/resources/glossary/uuid