# 데이터베이스의 가치

## 동시성

- 여러 사용자(트랜잭션이) 하나의 데이터 자원에 접근할 수 있는 성질
- 실시간 서버에서 중요한 가치
- 주로 조회 연산에서 초점

## 무결성

- 데이터가 일관되고 정확하게 유지되는 성질
- 안전하게 관리되는 것이 제 1의 목적
- 데이터 변경과 같은 쓰기 연산에서 주로 초점

# 락

## 비관적 락

> “다른 트랜잭션이 접근할지도 모른다”고 가정하고, 데이터 조회 시점에 락을 걸어버리는 방식
> 
- 데이터베이스 자원에 대한 동시 접근 충돌을 방지하기 위한 예방적 락, 주로 RDBMS가 사용
- 하나의 트랜잭션이 완전히 수행될 때까지 다른 트랜잭션은 데이터에 접근할 수 없다. → 안전하다.
    - 특히 데이터 동시 변경(쓰기 작업)이 잦은 환경에서 효과적
- 하나의 트랜잭션이 수행되는데 시간이 오래 걸리면 교착상태에 빠질 수 있다.
- Spring Data JPA에서는 `@Lock(LockModeType.PESSIMISTIC_WRITE)`로 구현 가능

---

 📍  **교착 상태 발생 조건** 

- 상호 배제 : 한 번에 하나의 프로세스만 자원을 사용할 수 있다.
- 점유 대기 : 프로세스가 최소 하나의 자원을 점유한 상태에서 다른 프로세스에 할당된 자원을 기다린다.
- 비선점 : 어떤 프로세스가 점유하고 있는 자원을 다른 프로세스가 강제로 빼앗을 수 없다.
- 순환 대기 : 각 프로세스가 순환적으로 자신이 점유한 자원을 다음 프로세스가 디라니느 상황

## 낙관적 락

> “동시에 접근해도 잘 안 겹칠 거야”라고 가정하고, 트랜잭션 커밋 직전에 버전(version)을 비교해서 충돌을 감지하는 방식
> 
- 사후적 락, 주로 NoSQL이 사용
- 충돌이 나면 예외 발생 → 다시 시도하는 재시도 로직이 필요하다.
- 락을 미리 걸지 않는다. → 동시성 높은 시스템에서 성능이 좋다. (실시간, 트래픽이 몰릴 수 있는 서비스)

📍  **MVCC (Multi-Version Concurrency Control)** 

> 낙관적 락의 구현체로 각 트랜잭션이 스냅샷을 보고 작업
> 
- 읽기 작업에서는 충돌 없음
- 쓰기 시접에 버전 불일치 시 충돌 감지

# 커넥션 풀

서버가 데이터베이스에 접근한다. ⇒ 네트워크 상에서 물리적 연결을 맺는다. 

트랜잭션 한 번 실행할 때마다 연결을 수립하고 종료하는 과정을 진행하면 I/O와 네트워크 비용이 커지고 지연이 발생한다. 

➡️ 커넥션 풀 등장 

**커넥션 풀은 무엇을 하는가?** 

DB 커넥션을 미리 여러 개 만들어 두구 요청이 들어올 때마다 풀에서 하나를 빌려쓰고, 작업이 끝나면 닫지 않고 풀에 반환하는 구조 

→ 매번 커넥션을 생성/파기하지 않아도 되기 때문에 자원 낭비가 줄고 요청 처리 속도가 일정하게 유지된다. 

→ 미리 만들어 둔걸로 재활용하기 때문에 효율이 좋다.

**어떤 점을 유의해야 할까?** 

> 얼마나 많이 만들고, 얼마나 오래 유지할 것인가?
> 
- 풀의 크기를 너무 크게 잡으면 → DB 입장에서 세션이 너무 많아져서 부하가 생길 수 있다.
- 풀의 크기를 너무 작게 잡으면 → 대기 큐가 길어져 지연이 생길 수 있다.
- 풀 커넥션 시간이 너무 길면 → 대기 큐가 길어져 지연이 생길 수 있다.
- 풀 커넥션 시간이 너무 짧으면 → 트랜잭션이 다 처리되기 전에 반환하게 되어 미완된 트랜잭션이 생길 수 있다.

**자바에서 커넥션이 어떻게 사용되는가?** 

자바 어플리케이션 → JDBC API → JDBC 드라이버 → 데이터베이스

- 위의 흐름으로 자바에서 데이터베이스에 접근한다.
- 자바 커넥션은 JDBC 드라이버를 통해서 데이터베이스에 연결을 수립하여 사용하게 된다.
- 커넥션을 매번 만들지 않고 `DriverManager.getConnection()` 같은 방식을 사용해서 커넥션을 연결한 다음에 반환하는 방식으로 커넥션 사용
- 대표: Hikari CP
    
    ![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FYbIjy%2FbtrpzK7fD7G%2FAAAAAAAAAAAAAAAAAAAAAOqiC3AAfuQUPQsBf4JXK3tuZZU959PifYP2gzdXqRW5%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DMwPwga84TkO%252BemFP%252FrC8Z9j7i5M%253D)
    

**참고** 

https://steady-coding.tistory.com/564

# 쿼리 캐시

데이터베이스 쿼리 실행 과정은 생각보다 비싸다. 

(1) SQL 파싱 → (2) 최적화 (실행 계획 생성) → (3) 디스크 I/O (실제 데이터 읽기) 

매번 이 단계를 거치는 것은 비효율적이기 때문에 이전과 동일한 쿼리라면 결과를 기억해주자! 

➡️ 쿼리 캐시 등장 

어떤게 쿼리 캐시인가? 조회 쿼리 결과를 메모리에 저장해 디스크 접근 없이 메모리에서 바로 결과를 반환 

**만약 데이터에 변경이 생긴다면** → 모든 캐시를 무효화 

작은 데이터 변경이라도 발생하면 모든 캐시를 삭제해야 하기 때문에 자주 변경되는 데이터가 있는 환경에서는 성능 저하 유발 가능 

MySQL 8.0부터는 사라진 기능 

대체해서 사용할 수 있는 것은 

📍 **InnoDB의 버퍼풀** 

![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fs342a%2FbtsjPI8NMkH%2FAAAAAAAAAAAAAAAAAAAAANpw-1jnmQW8inPFDfFfdBXPNnD4UOAzSf0pHy-fvQIj%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DWoj%252FUoiHLeaB4WvYUGv%252Byj%252B%252FOTs%253D)

디스크의 데이터 파일, 인덱스 정보를 메모리에 캐시해두고 사용하는 공간으로 전체 메모리 공간의 50% 이상을 차지할 수 있다. 데이터는 페이지 단위로 캐싱한다. 

구조 : Free, Flush, LRU List 

- `Free` → 실제 사용자 데이터로 채워지지 않은 비어있는 페이지 목록
- `Flush` → 디스크 동기화되지 않은 데이터를 가진 데이터 페이지 (dirty page)
    
    데이터가 변경되면 redo 로그와 버퍼 풀의 데이터 페이지에 기록 
    
    하지만 바로 반영되지 않기 때문에 일종의 체크포인트처럼 Flush 리스트에 두고 동기화 
    
- `LRU List/MRU List` → 디스크로부터 읽어온 페이지들

데이터 변경 시 디스크에 바로 쓰지 않고 메모리 상에서 모은다. 

- 쿼리가 들어오면 버퍼풀 메모리 상의 페이지를 수정한다. → 수정한 페이지는 더티 페이지
- 일정 주기나 트랜잭션 커밋 시점에 백그라운드 스레드가 더티페이지를 디스크로 펄러시 한다.
- 버퍼풀에 먼저 반영하고 나중에 디스크에 반영하는 write-back 방식이다.

📍 **애플리케이션 레벨의 캐시 (Redis)** 

- 인메모리 데이터 저장소 → 접근 속도가 빠르다
- Key-Value 구조의 NoSQL
- DB 외부에서 쿼리 결과나 연산 결과를 캐싱하는 분산 캐시

---

[https://velog.io/@semi-cloud/DB-InnoDB-버퍼-풀](https://velog.io/@semi-cloud/DB-InnoDB-%EB%B2%84%ED%8D%BC-%ED%92%80)

https://cl8d.tistory.com/102