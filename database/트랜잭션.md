작성일 | 251025

## Transaction

데이터베이스의 상태를 변경하는 SQL 연산들을 하나의 논리적 단위로 묶은 것 

⇒ 성공하면 전부 반영(commit) / 실패하면 전부 취소 (rollback)

**트랜잭션의 수행 상태는 4가지가 존재한다.** 

- `active`: 트랜잭션 활동 상태 → 트랜잭션이 실행 중이며 DB 내에서 활발하게 작업이 이루어지고 있는 상태
- `partially committed`: 트랜잭션의 커밋 명령이 도착한 상태
    
    → 모든 명령이 성공적으로 실행되었고, commit 명령만 남은 상태 
    
    → commit 명령만 남은 상태 
    
- `aborted`: 트랜잭션이 취소되었고 트랜잭션 실행 이전 데이터로 돌아가는 상태
    
    → rollback 명령이 실행 
    
- `failed`: 트랜잭션 실패 상태
    
    → 트랜잭션이 정상적으로 진행될 수 없는 상태 
    
- `committed`: 트랜잭션 완료 상태
    
    → 트랜잭션이 모두 실행되고 DB에 영구적으로 반영된 상태  
    

## ACID

트랜잭션이 수행될 때 DB의 일관성을 보장하기 위해 수행되는 약속 

**Atomicity (원자성)**

트랜잭션에 포함되는 모든 작업이 모두 성공하거나, 모두 실패해야 한다는 원칙 

- 성공하면 commit 실패하면 rollback

**Consistency (일관성)**

트랜잭션 전후로 DB의 제약 조건과 비즈니스 규칙이 항상 유지되어야 함 ⇒ 데이터 무결성이 깨지면 안됨 

트랜잭션 수행 전후의 데이터가 논리적으로 일관된 상태 

JPA에서는 엔터티 매핑을 통해 무결성 제약 (`@NotNull`, `@OneToMany`)을 유지함으로써 일관성을 보조한다. 

→ DB 수준 제약 조건을 만족하는 것이 중요 

**Isolation (격리성)**

동시에 여러 트랜잭션이 실행되더라도, 각 트랜잭션은 서로 간섭받지 않아야 한다. 

→ 내가 읽거나 수정하는 데이터는 트랜잭션이 끝날 때까지 다른 트랜잭션에서 접근하거나 변경할 수 없다. 

Spring에서 어노테이션으로 격리 수준을 설정할 수 있다. 

```java
@Transactional(isolation = Isolation.REPEATABLE_READ)
```

**Durability (지속성)**

트랜잭션이 성공적으로 커밋되면, 그 결과는 시스템 장애가 발생해도 보존되어야 하는 원칙

- DB 서버가 꺼지거나 전원이 나가도 커밋된 데이터는 디스크에 영구 저장되어야 함 (영속성)

**지속성은 DBMS의 역할이다.** 

- DBMS는 커밋 시점에 로그를 디스크에 기록
- 장애 발생 시 로그 기반으로 복구 수행
- 해당 역할은 애플리케이션보다 DB 엔진이 보장하는 영역

## Isolation Level (격리 수준)

트랜잭션 고립의 정도에 대한 정의 : 얼마나 독립적으로 실행할 것인가

→ 트랜잭션 격리성: 동시에 트랜잭션이 수행될 때 각 트랜잭션은 서로 간섭받지 않아야 한다. 

→ 동시 실행되는 트랜잭션 간 데이터 일관성을 보장하면서 성능 손실을 최소화하기 위한 설정 

**`Read Uncommitted` 0** 

> **다른 트랜잭션이 아직 커밋하지 않은 변경사항도 읽을 수 있다.**
데이터 일관성이 깨질 위험이 너무 크다. ⇒ 실무에서 거의 사용하지 않음
> 

| Dirty Read | Non-Repeatable Read | Phantom Read  |
| --- | --- | --- |
| ⭕️ | ⭕️ | ⭕️ |

**Dirty Read 발생 가능** 

트랜잭션 a가 아직 커밋하지 않은 데이터를 트랜잭션 b가 읽어버림 

⇒ a가 롤백하면, b는 존재하지 않는 데이터를 읽은 꼴이 됨 

```sql
-- 트랜잭션 a
UPDATE account SET balance = 0 WHERE id = 1; // 아직 커밋 안함 

-- 트랜잭션 b
SELECT balance FROM account WHERE id = 1; // balance = 0 
```

**`Read Committed` 1**

> **오직 커밋된 데이터만 읽을 수 있다.** 
대부분의 RDBMS의 기본 수준
> 

| Dirty Read | Non-Repeatable Read | Phantom Read  |
| --- | --- | --- |
| ❌ | ⭕️ | ⭕️ |

**Dirty Read 방지** 

**Non-repeatable Read 발생 가능** 

같은 SELECT를 2번 실행했는데, 다른 트랜잭션이 중간에 값을 바꿔버리면 결과가 달라짐 

한 행에 대한 버전 스냅샷을 매번 새로 만들어 읽는다. 

```sql
--트랜잭션 a 
SELECT balance FROM account WHERE id = 1; -- 1000원 

--트랜잭션 b
UPDATE account SET balance = 500 WHERE id = 1; 
COMMIT; 

-- 트랜잭션 a
SELECT balance FROM account WHERE id = 1; -- 500원 
```

**`Repeatable Read` 2**

> 트랜잭션이 시작될 때의 스냅샷 시점(view)을 기준으로 모든 SELECT 수행 
MySQL InnoDB의 기본 격리 수준
> 

| Dirty Read | Non-Repeatable Read | Phantom Read  |
| --- | --- | --- |
| ❌ | ❌ | ⭕️ |

다른 트랜잭션이 새로운 행을 Insert했을 때 발생 

그러나 MySQL InnoDB에서는 `Gap Lock`과 `Next-Key Lock` 등을 사용해서 Phantom Read도 방지 가능

```sql
--트랜잭션 a 
SELECT * FROM orders WHERE price > 100; -- 3 rows 

-- 트랜잭션 b 
INSERT INTO orders VALUES (999, 'itemX', 200); 
COMMIT; 

-- 트랜잭션 a 
SELECT * FROM orders WHERE price > 100; -- 4 rows (Phantom) 
```

**`Serializable` 3**

> 모든 트랜잭션을 순차적(직렬화된)으로 실행한 것처럼 보이게 하는 가장 엄격한 수준
> 

| Dirty Read | Non-Repeatable Read | Phantom Read  |
| --- | --- | --- |
| ❌ | ❌ | ❌ |

Lock을 대량으로 발생시켜서 → 동시성 하락

⇒ 동시성은 DB가 동시에 여러 트랜잭션을 병렬로 처리하는 능력 

Lock은 트랜잭션 실행을 직렬적으로 관리 ⇒ 하나의 데이터에 접근하는 트랜잭션을 단속한다. → 병렬로 데이터(자본)을 활용하기 어렵게 된다. 

## 이상현상

**Dirty Read**

> 커밋되지 않은 데이터를 읽을 수 있는 현상
> 
- `ROLLBACK`될수도 있는 값을 읽은 상태
- 커밋되지 않았기 때문에 실제 DB 상태와 불일치할 수 있음

**Non-Repeatable Read**

> 같은 쿼리 내에서 동일 쿼리 결과가 달라지는 현상
> 
- 다른 트랜잭션이 중간에 데이터를 수정하거나 삭제해서 결과가 달라짐
- 커밋된 데이터만 읽긴 하지만, 일관성이 깨짐
- 매번 스냅샷을 찍어야 함

**Phantom Read**

> 같은 조건으로 조회했을 때, 데이터가 조회되지 않는 현상
> 
- 다른 트랜잭션이 중간에 새로운 행을 insert해서 나타나는 현상