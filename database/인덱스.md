작성 일시 | 251023

# Disk I/O

데이터베이스는 영속성을 위해서 데이터를 디스크에 저장하고 관리한다. → 데이터 영구 저장 가능 

디스크에서 데이터를 읽고 쓰는 작업은 시간이 오래 걸리고 속도가 느리다. 

그래서 DB의 모든 최적화는 디스크 I/O를 최소화하는 방향으로 움직인다. 

# Full Table Scan (순차 접근)

데이터가 저장된 목록 중 모든 데이터 요소를 하나씩 조사하는 접근 방식 

**어떻게 진행할까?** 

1. DB는 테이블의 모든 데이터 페이지(디스크 블록)을 읽는다.
2. 각 블록에는 수십 ~ 수백개의 행이 들어있고, 그걸 전부 메모리로 올려서 조건에 맞는지 확인한다. 
    
    즉 Full Table Scan = 디스크 전체 탐색 
    

**언제 일어날까?** 

- WHERE 조건이 인덱스 컬럼이 아닐때
- 조건이 인덱스를 비효율적으로 사용할때
    - LIKE 안티패턴
- 결과가 테이블의 대부분일때 (결국 어쨌거나 전체를 다 탐색해야 하는 경우)

**참고** 

https://hoon93.tistory.com/53

https://dodo000.tistory.com/22#google_vignette

# 정의

색인 | 테이블에 대한 **조회** 동작의 속도를 높여주는 자료구조 

DB는 일부만 읽고도 원하는 데이터를 찾기 위해서 만든 인덱스 구조 

# 구조

## B-Tree

<aside>
💛

- B-Tree는 이진 트리를 확장한 구조로, 한 노드가 여러 자식을 가질 수 있어 트리의 높이가 낮고 탐색 효율이 높다.
- 탐색 시간복잡도는 `O(logₘN)`이며, 한 노드가 저장하는 키 개수(M)가 많을수록 탐색 단계가 줄어든다.
- 모든 노드에 데이터가 저장되어 있어 Range Scan과 연속적 데이터 접근이 비효율적이다.
</aside>

**Balanced Tree → 한 쪽으로 경사가 지지 않는다.** 

**이진 트리를 확장한 형태로 노드가 가질 수 있는 자식 노드의 최대 숫자가 2보다 큰 트리 구조** 

- 이진 트리는 기본적으로 자신보다 작은 값을 왼쪽, 큰 값을 오른쪽에 정렬하여 2개의 자식 노드를 갖는 구조
- 데이터 탐색의 효율을 위해서는 낮은 트리가 필요함
- 하나의 노드에 더 많은 범위를 다루기 위해 2개 이상의 노드들을 관리

⇒ 이렇게 하면 하나의 부모 노드 아래에 여러 자식 노드를 가질 수 있게 된다. → 트리의 높이가 낮아져 탐색해야하는 범위를 줄일 수 있다. → 탐색 효율이 좋아진다. 

**시간복잡도는 Log**

- 이진 탐색 트리의 시간 복잡도는 Log2(N)
    - 정렬된 트리를 절반씩 나누어서 탐색하기 때문
- B-Tree의 경우 탐색 시간복잡도는 logM(N)
    - 하나의 노드에 몇 개의 데이터를 보유하느냐(M)에 따라서 트리를 몇 번씩 쪼개어서 계산하면 되는지 알 수 있음

**데이터는 모든 노드에 저장된다.** 

- 트리의 모든 노드에 데이터가 저장
- 중간 노드에도 데이터가 있으므로 range scan(범위 탐색)이 비효율적
    - range scan이 뭐지? 범위가 주어지면 해당 범위에 대해서 데이터를 탐색하는 방식
    - 중간 노드에 데이터가 있기 때문에 하나씩 찾아보면서 해당되는 값인지 아닌지 일일히 확인하는 작업이 필요하다. 즉 처음과 끝이 어디서부터 어디까지 존재하는지 불확실하다.
- 리프 노드끼리 연결되어있지 않아 연속적인 데이터 읽기에 불리
- 디스크 I/O의 지역성이 떨어진다.

## B+Tree

<aside>
💛

- B+Tree는 데이터가 **오직 리프 노드에만 저장**되며, 리프 노드들은 포인터로 서로 연결되어 연속적 접근(Range Scan)이 가능하다.
- 내부 노드는 탐색용 **Key와 하위 노드 Pointer**만 가지므로 한 노드가 더 많은 키를 저장할 수 있고, 트리 높이가 낮아져 **디스크 I/O가 감소**한다.
- 결과적으로 **트리 깊이가 얕고 탐색 효율이 높은** 구조로, 데이터베이스 인덱스에 최적화되어 있다.
</aside>

B-Tree의 변형

**데이터는 오직 리프노드에만** 

- 데이터는 오직 리프노드에만 저장
- 다른 노드들은 서로의 앞, 뒤에 해당하는 데이터를 포인터로 가리킨다. (연결형 리스트)
- 같은 높이에 있는 노드들은 서로 연결되어있음 (브랜치 노드의 경우에도 해당)

**하나의 노드에 담을 수 있는 데이터 양이 많아짐**

- 데이터베이스의 인덱스는 페이지에 저장 (4KB)
- 각 노드가 한 페이지에 해당
- 한 노드에 많은 키를 담을수록 → 트리의 노드가 표현할 수 있는 수가 많아지고 → 높이가 낮아진다.
- 높이가 낮아지면 디스트 i/o가 줄어들어서 검색이 빨라진다. **⇒ 탐색 효율 향상 !**

**B+Tree의 노드는 어떻게 구성되는가?** 

| key | pointer | key | pointer | key |
| --- | --- | --- | --- | --- |
| 5 | <<다음노드>> | 10 | <<다음노드>> | 15  |
- Key : 탐색용 키
- Pointer : 하위노드 포인터

# 종류

## Clustered Index

<aside>
💛

- Clustered Index는 **데이터 테이블 자체가 인덱스로 사용**되어, 인덱스 테이블 없이 데이터가 인덱스 순서대로 저장된다.
- 데이터 페이지들이 **클러스터드 키 순서로 논리적 정렬**을 유지하며, 디스크 페이지 단위에서만 순서성을 보장한다.
- **테이블당 하나만 설정 가능**하며, 물리적 재배열이 수반되어 쓰기 작업이 느리지만, 조회는 매우 빠르다.
</aside>

**데이터가 인덱스 순서대로 저장된 테이블 구조**

- 별도의 인덱스 테이블을 만들지 않고 데이터 테이블 자체를 인덱스로 사용
- 데이터 조회시 인덱스 테이블과 데이터 테이블 사이의 별도 이동 없이 바로 접근 가능
- 하나의 테이블에는 하나의 clustered index만 가질 수 있음

**테이블의 데이터 페이지들이 클러스터드 키 순서대로 연결되어 관리** 

- 데이터는 논리적으로 인덱스 순서에 맞춰 B+Tree 구조로 배치
- DB 엔진이 디스크 페이지 단위로 순서성을 유지하도록 관리
- 실제 디스크 상의 바이트 단위 물리 주소가 완전히 정렬되는 것은 아님

**테이블에서 어떤 설정을 갖는가?**

- 테이블 당 1 개만 허용
- 물리적으로 레코드 재배열 ⇒ 데이터 추가, 삭제 등의 작업에서는 매번 정렬 작업이 진행됨
- pk 설정시 `autoIncrement` 되는 방식

# Non-Clustered Index

<aside>
💛

- Non-Clustered Index는 별도의 인덱스 테이블에 저장되며, 원본 데이터 위치를 가리키는 포인터만 포함하므로 **추가 저장공간이 필요**하다.
- 서로 다른 조회 패턴(WHERE, JOIN, ORDER BY 등)에 맞게 여러 인덱스를 생성할 수 있지만, **쓰기 부하 증가**에 주의해야 한다.
- `UNIQUE` 제약을 설정하면 **Non-Clustered Unique Index가 자동 생성**되며, 물리적 정렬은 수행되지 않아 생성은 빠르지만 조회는 상대적으로 느리다.
</aside>

**인덱스 테이블이 따로 관리** 

- 인덱스가 별도의 인덱스 테이블에 저장되고 원본 데이터 위치를 가리키는 포인터만 포함
- 원본 테이블은 수정이 없음
- 추가 용량이 필요하다.

**한 테이블에 여러 개의 Non-Clustered Index 생성 가능** 

- 조회 패턴이 서로 다른 경우
- 쿼리 조건 (WHERE, JOIN, ORDER BY, GROUP BY)이 서로 다른 컬럼에 해당되는 경우
    
    → 각각의 조건에 맞는 인덱스를 만들고 해당 인덱스를 바탕으로 테이블 스캔을 수행할 수 있다. 
    
- 주의: 인덱스는 쓰기 부하를 증가시키므로 조회 빈도가 높은 컬럼을 선택적으로 사용할 것

**추가적인 설정** 

- `unique` 제약 조건 설정 시 자동으로 Non-Clustered Index 생성
    - unique 제약 조건 → 컬럼 내 중복 값을 허용하지 않는다.
    - 인덱스 기반 검사로 중복 검사를 빠르게 수행할 수 있음
- 물리적 정렬 작업이 수행되지 않음
    
    → 조회 속도는 느리지만 추가, 생성에서는 빠름 
    

# 인덱스와 프라이머리 키

- Primary Key
    
    → 개념적 유일성 제약 : 데이터 중복을 막고 각 튜플을 식별 
    
    → DB에서 PK를 설정하면 자동으로 인덱스 생성 (이미 인덱스화)  
    
- Index
    
    → 물리적 접근 구조: 데이터를 빠르게 찾게 해주는 구조 
    
- PK 만으로 빠른 조회가 보장되지 않으며, 인덱스가 있어야 효율적인 탐색이 가능

**흐름** 

1. `LastName`을 **Primary Key**로 설정한다 → 이 컬럼은 테이블에서 **유일성을 보장**한다.
2. DBMS는 Primary Key를 설정하는 순간, **자동으로 인덱스를 생성**한다.
3. 따라서 별도의 테이블 순회 없이, **인덱스를 통해 즉시 해당 튜플을 조회**할 수 있다.
4. 인덱스는 DB 내부에 별도의 공간으로 관리되며, 데이터 위치를 포인터로 가리킨다.

https://www.youtube.com/watch?v=MuZ-Mx0N-dA

# 참고

https://10000cow.tistory.com/entry/%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-B-%ED%8A%B8%EB%A6%AC

https://munak.tistory.com/182

https://choiblack.tistory.com/53

https://learn.microsoft.com/en-us/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described?view=sql-server-2017