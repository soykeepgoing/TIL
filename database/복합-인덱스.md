작성일 | 251024

# 복합 인덱스의 동작원리와 컬럼 순서 결정 시 고려해야 하는 요소는 무엇인가? 

### 복합 인덱스란?

<aside>
🧠

- 복합 인덱스는 여러 컬럼을 하나의 인덱스로 묶은 것이다.
- MySQL은 최대 16개 컬럼까지 하나의 인덱스로 구성할 수 있다.
- 복합 인덱스는 정렬된 배열로 볼 수 있으며 각 행에는 인덱스된 열의 값을 연결하여 생성된 값이 포함된다.
</aside>

**복합 인덱스는 여러 컬럼을 인덱스로 만드는 것이다.** 

- MySQL은 최대 16개 컬럼까지 하나의 인덱스로 구성 가능
- 여러 컬럼 조합 검색 시 성능 향상이 가능
- 각 컬럼을 hashed하는 컬럼으로 복합 인덱스를 대체할 수 있다.
    
    → 넓은 범위의 컬럼들에 대해서 커버하지 않을 수 있어 더 빠르게 사용될 수도 있음 
    

**왼쪽부터 순차적으로 사용하는 쿼리에서만 효율적으로 활용된다.** 

- 내부적으로 정렬된 배열 구조로 관리된다.
- 각 행은 인덱스된 컬럼들의 값을 연결하여(**concatenate**) 하나의 키로 본다. → 연결된 값이 포함되는 튜플

### 동작 원리

<aside>
🧠

1. 복합 인덱스는 각 컬럼들의 값을 연결한 키의 형태로 관리하고, 해당 키 값을 기준으로 사전순으로 정렬된 b-tree에서 관리한다. 
2. 복합 인덱스를 활용해 데이터를 조회하면, 복합 인덱스 중 가장 왼쪽에 있는 컬럼부터 순차적으로 탐색하는 Leftmost Prefix Rule을 따른다. 
3. 복합 인덱스 (col1, col2, col3)이 있는 경우 인덱스를 사용하는 경우는 (col1), (col1, col2), (col1, col2, col3)이다. 
</aside>

**단일 인덱스로 설정되면 MySQL은 index merge(병합)을 시도한다.** 

- 행들을 순회하면서 스캔을 거친 뒤 하나의 결과로 결과를 병합한다. (intersect / union / sort-union)
- 최적의 선택이 아닐 수 있음
    - 복잡한 WHERE 절 구조에 취약 → AND/OR로 중첩되어 조회되는 경우 성능에 무리
    - FULLTEXT 인덱스가 걸린 조건에는 동작하지 않음
    - 단일 테이블 내부에서만 동작한다. → 조인된 여러 테이블에 대해서는 적용할 수 없다.
- 단일 인덱스로 스캔하고 결과를 병합하는 과정에서 추가적인 메모리 병합 비용이 발생한다.

**B-Tree 내부적으로 키는 연결되어 관리된다.** 

- (col1, col2) 라는 연결된 복합 인덱스가 있다면
    - 같은 col1에 대해서 1차 정렬하고,
    - 그 다음에 col2 기준으로 2차 정렬
- 순서로 정리하면,
    1. 첫번째 컬럼 비교 
    2. 같다면 두번째 컬럼 비교 
    3. 또 같다면 세 번째 컬럼 비교 … 
    
    → (col1) , (col1, col2), (col1, col2, col3) , … 과 같이 순차적으로 하나의 키를 이룬다. 
    
    → (col1, col2) 와 (col2, col1)은 서로 다른 키다. 왜? 트리 구조 자체가 다르니까
    

### 키 순서 결정 시 고려 사항

<aside>
🧠

1. 인덱스 조회 조건으로 자주 사용되는 속성 → 선두 
2. 카디널리티가 높을수록 → 선두 
3. 속성이 연속될수록 → 선두 
4. 자주 변경되지 않는 값일수록 → 선두 
</aside>

**복합 인덱스에서 인덱스 조회 조건으로 자주 사용되는 순서로 정의해야 한다.** 

- 복합 인덱스는 인덱스 순서대로 정의된다.
- Leftmost 인덱스는 인덱스 조회에 포함되는 속성일수록 유리하다.
- 인덱스 조회에 자주 포함되지 않는 속성이 Leftmost에 위치하게 된다면 인덱스 활용도가 매우 낮다.

**카디널리티는 높을수록 첫번째 순서에 배치되어야 성능이 향상된다.** 

- 카디널리티는 컬럼 내 유니크한 값의 수
    - 카디널리티가 높다 → 중복된 값이 적다 → 튜플 구분이 뚜렷하다 → 선택도가 높아진다. ⇒ 주민번호
    - 카디널리티가 낮다 → 중복된 값이 많다 → 튜플 구분이 잘 안된다 ⇒ 성별
- 선택도 값이 높으면 인덱스가 더 유리하게 작용할 가능성이 크다.

**속성이 연속될수록 첫번째 순서에 배치되어야 성능이 향상된다.** 

- B-Tree 노드 삽입 동작 원리
    1. 데이터 삽입 
    2. (삽입 공간 부족시) 새로운 페이지 생성 및 분할 
    3. 키 재배치
    4. 부모 노드 업데이트 
- 연속적인 값이 복합키 인덱스 첫번째 순서에 배치되어야 삽입 성능이 향상된다.
    
    → 연속적인 값을 삽입한다면 데이터가 삽입되는 방향이 정해진다. (값이 가장 크거나 작은 경우) 
    
    → B-Tree 삽입 단계에서 3번 (키 재배치)가 덜 자주 발생한다. 
    
- 불연속적인 값이 삽입되면 키 재배치를 위한 과정이 자주 발생해 페이지 생성, 데이터 이동에서 잦은 Disk I/O를 유발하고, 삽입 성능이 떨어질 수 있다.

**자주 갱신되는 컬럼은 후순위에 두는게 유리하다.** 

- B+Tree 트리에서 노드가 갱신되면 트리 내부에서 노드 분할 (split), 리밸런싱(rebalance), 리프 재정렬이 발생한다.
- 인덱스 키의 선두 부분이 바뀌면 물리적으로 데이터의 위치 자체가 달라진다.
    
    → 인덱스의 루트 ~ 브릿지 노드에 있는 분기 키들이 바뀌게 된다. 
    
- 인덱스 키의 후미 부분이 바뀌면 리프 노드의 정렬 순서만 바뀐다.
    
    → 루트 ~ 브릿지 노드가 변하지 않는다.
    
    → 물리적 리밸런싱 부담이 거의 없다. 
    


### 예시

```sql
CREATE TABLE test (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
```

```sql
// 제대로 동작하는 경우 
SELECT * FROM test
  WHERE last_name='Jones'
  AND first_name >='M' AND first_name < 'N';
```

```sql
// 제대로 동작하지 않는 경우 
SELECT * FROM test WHERE first_name='John';

SELECT * FROM test
  WHERE last_name='Jones' OR first_name='John';
```

## 참고

https://dev.mysql.com/doc/refman/8.4/en/mysql-indexes.html

https://dev.mysql.com/doc/refman/8.4/en/multiple-column-indexes.html

https://dev.mysql.com/doc/refman/8.4/en/index-merge-optimization.html

https://dev.mysql.com/doc/refman/8.0/en/column-indexes.html

https://haileyjpark.tistory.com/22

https://velog.io/@junho100/%EB%B3%B5%ED%95%A9%ED%82%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%88%9C%EC%84%9C%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%A1%B0%ED%9A%8C-%EC%82%BD%EC%9E%85-%EC%84%B1%EB%8A%A5-%EC%B0%A8%EC%9D%B4

https://prohannah.tistory.com/99

https://planetscale.com/learn/courses/mysql-for-developers/indexes/index-selectivity?utm_source=chatgpt.com
